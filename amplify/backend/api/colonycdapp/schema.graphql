# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
# NOTE: This file is getting out hand in terms of size
# There is an official way of splitting the schema into multiple files
# https://docs.amplify.aws/cli-legacy/graphql-transformer/overview/#api-category-project-structure
# but I never could get it to work

"""
Input data for fetching a token's information from _everywhere_ ??? I'm not sure what that means ???.
"""
input TokenFromEverywhereArguments {
  """Address of the token on the blockchain."""
  tokenAddress: String!
}

"""
Input data for fetching the list of members for a specific Colony.
"""
input MembersForColonyInput {
  """Address of the Colony."""
  colonyAddress: String!
  """Root hash for the reputation state."""
  rootHash: String
  """ID of the domain within the Colony."""
  domainId: Int
  """Sorting method to apply to the member list."""
  sortingMethod: SortingMethod
}

"""
Input data for creating a unique user within the Colony Network.
??? I'm not really sure what unique means in this context, I would like to add an explanation here thought ???
"""
input CreateUniqueUserInput {
  """Unique identifier for the user. This is the user's wallet address."""
  id: ID!
  """The username."""
  name: String!
  """Profile data for the user."""
  profile: ProfileInput
}

"""
??? Not really sure what this is. It's also not used anywhere ???
"""
enum EmailPermissions {
  """Permission to send notifications to the user."""
  sendNotifications
  """Permission to identify the user as a human (??? as opposed to a contract ???)."""
  isHuman
}

"""
Input data for a user's profile metadata.
"""
input ProfileMetadataInput {
  """List of email permissions for the user."""
  emailPermissions: [String!]!
}

"""
Input data for relevant chain metadata of a Colony.
??? I would like to explain why we need this but maybe that's too much info ???
"""
input ChainMetadataInput {
  """The network the Colony is deployed on."""
  network: Network
  """The chain ID of the network."""
  chainId: Int
  """The transaction hash of the creation transaction."""
  transactionHash: String
  """The log index of the creation transaction."""
  logIndex: Int
  """The block number of the creation transaction."""
  blockNumber: Int
}

"""
Input data for the status of a Colony's native token.

Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later.
"""
input NativeTokenStatusInput {
  """Whether the native token is unlocked."""
  unlocked: Boolean
  """Whether the native token is mintable."""
  mintable: Boolean
  """Whether the native token can be unlocked."""
  unlockable: Boolean
}

"""
Input data for a Colony's status information.

This is set when a Colony is created and can be changed later.
"""
input ColonyStatusInput {
  """Status information for the Colony's native token."""
  nativeToken: NativeTokenStatusInput
  """Whether the Colony is in recovery mode."""
  recovery: Boolean
}

"""
Input data for creating a unique Colony within the Colony Network.

??? I'm not really sure what unique means in this context, I would like to add an explanation here thought ???
"""
input CreateUniqueColonyInput {
  """Unique identifier for the Colony. This is the Colony's contract address."""
  id: ID!
  """Display name of the Colony."""
  name: String!
  """Unique identifier for the Colony's native token."""
  colonyNativeTokenId: ID!
  """Type of the Colony (regular or MetaColony)."""
  type: ColonyType
  """Status information for the Colony."""
  status: ColonyStatusInput
  """Metadata related to the Colony's creation on the blockchain."""
  chainMetadata: ChainMetadataInput
  """Version of the currently deployed Colony contract."""
  version: Int!
}

"""
Input data to use when creating or changing a user profile
"""
input ProfileInput {
  """The unique identifier for the user profile."""
  id: ID
  """The URL of the user's avatar image."""
  avatar: String
  """The URL of the user's thumbnail image."""
  thumbnail: String
  """The display name of the user."""
  displayName: String
  """A short description or biography of the user."""
  bio: String
  """The user's location (e.g., city or country)."""
  location: String
  """The user's personal or professional website."""
  website: AWSURL
  """The user's email address."""
  email: AWSEmail
  """Any additional metadata or settings related to the user profile."""
  meta: ProfileMetadataInput
}

"""
Input data for a user's reputation within a Domain in a Colony. If no `domainId` is passed, the Root Domain is used.
A `rootHash` can be provided, to get reputation at a certain point in the past.
"""
input GetUserReputationInput {
  """The Ethereum wallet address of the user."""
  walletAddress: String!
  """The Ethereum address of the Colony."""
  colonyAddress: String!
  """The ID of the Domain within the Colony. If not provided, defaults to the Root Domain."""
  domainId: Int
  """The root hash of the reputation tree at a specific point in time."""
  rootHash: String
}

"""
Input data for updating an extension's information within a Colony, based on the Colony ID and extension hash.
The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
"""
input UpdateExtensionByColonyAndHashInput {
  """The unique identifier for the Colony."""
  colonyId: ID!
  """The hash of the extension to be updated."""
  hash: String!
  """A flag to indicate whether the extension is deprecated."""
  isDeprecated: Boolean
  """A flag to indicate whether the extension is deleted."""
  isDeleted: Boolean
  """A flag to indicate whether the extension is initialized."""
  isInitialized: Boolean
  """The version of the extension."""
  version: Int
  """The Ethereum address of the user who installed the extension."""
  installedBy: String
  """The timestamp when the extension was installed."""
  installedAt: AWSTimestamp
}

"""
???: what is this?
"""
input SetCurrentVersionInput {
  """???"""
  key: String!
  """???"""
  version: Int!
}

"""
???: what is this?
"""
type TokenFromEverywhereReturn {
  """???"""
  items: [Token]
}

"""
Input data for retrieving a user's reputation within the top ??? domains of a Colony.
"""
input GetReputationForTopDomainsInput {
  """The Ethereum wallet address of the user."""
  walletAddress: String!
  """The Ethereum address of the Colony."""
  colonyAddress: String!
  """The root hash of the reputation tree at a specific point in time."""
  rootHash: String
}

"""
Input data for retrieving a user's token balance for a specific token.
"""
input GetUserTokenBalanceInput {
  """The Ethereum wallet address of the user."""
  walletAddress: String!
  """The Ethereum address of the token."""
  tokenAddress: String!
}

"""
A type representing a user's reputation within a domain.
"""
type UserDomainReputation {
  """The integer ID of the Domain within the Colony."""
  domainId: Int!
  """The user's reputation within the domain, represented as a percentage."""
  reputationPercentage: String!
}

"""
A return type that contains an array of UserDomainReputation items.
"""
type GetReputationForTopDomainsReturn {
  """An array of UserDomainReputation items."""
  items: [UserDomainReputation!]
}

"""
A return type representing the breakdown of a user's token balance.
"""
type GetUserTokenBalanceReturn {
  """The total token balance, including inactive, locked, and active ??? and pending ??? balances."""
  balance: String
  """The inactive portion of the user's token balance."""
  inactiveBalance: String
  """The locked portion of the user's token balance."""
  lockedBalance: String
  """The active portion of the user's token balance."""
  activeBalance: String
  """The pending portion of the user's token balance."""
  pendingBalance: String
}

"""
A return type representing the members of a Colony.

Definitions:
* Member = User watching a Colony, with or without reputation
* Contributor = User watching a Colony WITH reputation
* Watcher = User watching a Colony WITHOUT reputation
"""
type MembersForColonyReturn {
  """User watching a Colony WITH reputation"""
  contributors: [Contributor!]
  """User watching a Colony WITHOUT reputation"""
  watchers: [Watcher!]
}

"""
Variants of different token types a Colony can use.
As Colonies can use multiple tokens and even own tokens (BYOT), we need to differentiate.
"""
enum TokenType {
  """A (ERC20-compatible) token that was deployed with Colony. It has a few more features, like minting through the Colony itself"""
  COLONY
  """An ERC20-compatible token"""
  ERC20
  """The native token of the Chain used (e.g. ETH on mainnet or xDAI on Gnosis-Chain)"""
  CHAIN_NATIVE
}


"""
Variants of supported Ethereum networks.
"""
enum Network {
  """Local development network using Ganache."""
  GANACHE
  """Ethereum Mainnet."""
  MAINNET
  """Ethereum Goerli test network."""
  GOERLI
  """Gnosis Chain network."""
  GNOSIS
  """Fork of Gnosis Chain for QA purposes."""
  GNOSISFORK
}

"""
Variants of available domain colors as used in the dApp.
"""
enum DomainColor {
  """A light pink color."""
  LIGHT_PINK
  """A pink color."""
  PINK
  """A black color."""
  BLACK
  """An emerald green color."""
  EMERALD_GREEN
  """A blue color."""
  BLUE
  """A yellow color."""
  YELLOW
  """A red color."""
  RED
  """A green color."""
  GREEN
  """A pale indigo color."""
  PERIWINKLE
  """A gold color."""
  GOLD
  """An aqua color."""
  AQUA
  """A blue-grey(ish) color."""
  BLUE_GREY
  """A purple color."""
  PURPLE
  """An orange color."""
  ORANGE
  """A magenta color."""
  MAGENTA
  """A purple-grey(ish) color."""
  PURPLE_GREY
}

"""
Variants of Colony types.
"""
enum ColonyType {
  """A regular Colony."""
  COLONY
  """The MetaColony, which governs the entire Colony Network."""
  METACOLONY
}

"""
Variants of Colony Network blockchain events.

These can all happen in a Colony and will be interpreted by the dApp according to their types.
"""
enum ColonyActionType {
  """A generic or unspecified Colony action."""
  GENERIC
  """ ??? """
  WRONG_COLONY
  """An action related to a payment within a Colony."""
  PAYMENT
  """An action related to the recovery functionality of a Colony."""
  RECOVERY
  """An action related to moving funds between domains."""
  MOVE_FUNDS
  """An action related to unlocking a token within a Colony."""
  UNLOCK_TOKEN
  """An action related to minting tokens within a Colony."""
  MINT_TOKENS
  """An action related to creating a domain within a Colony."""
  CREATE_DOMAIN
  """An action related to upgrading a Colony's version."""
  VERSION_UPGRADE
  """An action related to editing a Colony's details."""
  COLONY_EDIT
  """An action related to editing a domain's details."""
  EDIT_DOMAIN
  """An action related to setting user roles within a Colony."""
  SET_USER_ROLES
  """An action related to a domain reputation penalty within a Colony (smite)."""
  EMIT_DOMAIN_REPUTATION_PENALTY
  """An action related to a domain reputation reward within a Colony."""
  EMIT_DOMAIN_REPUTATION_REWARD
}

"""
Variants of sorting methods for a member list.
"""
enum SortingMethod {
  """Sort members by highest reputation."""
  BY_HIGHEST_REP
  """Sort members by lowest reputation."""
  BY_LOWEST_REP
  """Sort members by having more permissions."""
  BY_MORE_PERMISSIONS
  """Sort members by having fewer permissions."""
  BY_LESS_PERMISSIONS
}

"""Root query type."""
type Query {
  """Fetch a token's information from _everywhere_ ??? not sure what this means ???."""
  getTokenFromEverywhere(
    input: TokenFromEverywhereArguments
  ): TokenFromEverywhereReturn @function(name: "fetchTokenFromChain")
  """Retrieve a user's reputation within the top ??? domains of a Colony."""
  getReputationForTopDomains(
    input: GetReputationForTopDomainsInput
  ): GetReputationForTopDomainsReturn
    @function(name: "getReputationForTopDomains")
  """Retrieve a user's reputation within a specific domain in a Colony."""
  getUserReputation(input: GetUserReputationInput): String
    @function(name: "getUserReputation")
  """Retrieve a user's token balance for a specific token."""
  getUserTokenBalance(
    input: GetUserTokenBalanceInput
  ): GetUserTokenBalanceReturn @function(name: "getUserTokenBalance")
  """Fetch the list of members for a specific Colony."""
  getMembersForColony(input: MembersForColonyInput): MembersForColonyReturn
    @function(name: "getMembersForColony")
}

"""
Root mutation type.
"""
type Mutation {
  """Create a unique user within the Colony Network. ??? Maybe explain why unique ???"""
  createUniqueUser(input: CreateUniqueUserInput): User
    @function(name: "createUniqueUser")
  """Create a unique Colony within the Colony Network. ??? Maybe explain why unique ???"""
  createUniqueColony(input: CreateUniqueColonyInput): Colony
    @function(name: "createUniqueColony")
  """ ??? I don't know what this is ??? """
  setCurrentVersion(input: SetCurrentVersionInput): Boolean
    @function(name: "setCurrentVersion")
  """
  Update an extension's details for a specific Colony.

  The extension hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network (e.g. `VotingReputation`)
  """
  updateExtensionByColonyAndHash(
    input: UpdateExtensionByColonyAndHashInput
  ): ColonyExtension @function(name: "updateExtensionByColonyAndHash")
}

"""
Represents a user's profile within the Colony Network.
"""
type Profile @model {
  """Unique identifier for the user's profile."""
  id: ID!
  """URL of the user's avatar image."""
  avatar: String
  """URL of the user's thumbnail image."""
  thumbnail: String
  """Display name of the user."""
  displayName: String
  """User's bio information."""
  bio: String
  """User's location information."""
  location: String
  """URL of the user's website."""
  website: AWSURL
  """User's email address."""
  email: AWSEmail @index(name: "byEmail", queryField: "getProfileByEmail")
  """Metadata associated with the user's profile."""
  meta: ProfileMetadata
}

"""
Represents the status of a Colony's native token.

Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later.
"""
type NativeTokenStatus {
  """Whether the native token is unlocked."""
  unlocked: Boolean
  """Whether the user has permissions to mint new tokens."""
  mintable: Boolean
  """Whether the native token can be unlocked."""
  unlockable: Boolean
}

"""
Represents the status of a Colony.

This contains important meta information about the Colony's token and other fundamental settings
"""
type ColonyStatus {
  """Status information for the Colony's native token."""
  nativeToken: NativeTokenStatus
  """Whether the Colony is in recovery mode."""
  recovery: Boolean
}

"""
Represents metadata related to a blockchain event.
"""
type ChainMetadata {
  """The network the event occurred on."""
  network: Network
  """The chain ID of the event."""
  chainId: Int
  """The transaction hash of the event."""
  transactionHash: String
  """The log index of the event."""
  logIndex: Int
  """The block number of the event."""
  blockNumber: Int
}

"""
Represents metadata for a user's profile. Mostly user specific settings.
"""
type ProfileMetadata {
  """List of email permissions for the user."""
  emailPermissions: [String!]!
}

"""
Represents a contributor within the Colony Network.

A contributor is a Colony member who has reputation.
"""
type Contributor {
  """User data associated with the contributor."""
  user: User
  """Reputation percentage of the contributor (of all reputation within the Colony)."""
  reputationPercentage: String
  """Reputation amount of the contributor (as an absolute number)."""
  reputationAmount: String
}

"""
Represents a watcher within the Colony Network.

A watcher is a Colony member who doesn't have reputation.
"""
type Watcher {
  """User data associated with the watcher."""
  user: User
}

"""Represents an ERC20-compatible token that is used by Colonies and users."""
type Token @model {
  """Unique identifier for the token (contract address)."""
  id: ID!
    @index(name: "byAddress", queryField: "getTokenByAddress")
    @index(sortKeyFields: ["createdAt"]) # contract address
  """Name of the token."""
  name: String!
  """Symbol of the token."""
  symbol: String!
  """Decimal precision of the token."""
  decimals: Int!
  """Type of the token. See `TokenType` for more information"""
  type: TokenType @index(name: "byType", queryField: "getTokensByType")
  """List of colonies using the token."""
  colonies: [Colony] @manyToMany(relationName: "ColonyTokens")
  """List of users using the token."""
  users: [User] @manyToMany(relationName: "UserTokens")
  """URL of the token's avatar image (logo)."""
  avatar: String
  """URL of the token's thumbnail image (Small logo)."""
  thumbnail: String
  """Metadata related to the chain of the token."""
  chainMetadata: ChainMetadata
  """Timestamp of the token model's creation in the database."""
  createdAt: AWSDateTime!
}

"""
??? I'm not really sure what this is
"""
type ColonyID {
  """Unique identifier for the Colony."""
  id: ID!
}

"""
Represents a Colony within the Colony Network.
"""
type Colony @model {
  """Unique identifier for the Colony (contract address)."""
  id: ID! @index(name: "byAddress", queryField: "getColonyByAddress")
  """(Short) name of the Colony."""
  name: String! @index(name: "byName", queryField: "getColonyByName")
  """The native token of the Colony."""
  nativeToken: Token! @hasOne
  """List of tokens that are used within the Colony."""
  tokens: [Token] @manyToMany(relationName: "ColonyTokens")
  """Status information for the Colony."""
  status: ColonyStatus
  """List of domains of the Colony."""
  domains: [Domain] @hasMany(indexName: "byColony", fields: ["id"])
  """List of users watching the Colony."""
  watchers: [User] @manyToMany(relationName: "WatchedColonies")
  """List of Colony funds claims for all ERC20 tokens."""
  # NOTE: Could not merge these two fields properly
  # Ideally we would merge data from these two into one field, but I couldn't do that
  # meaning we'll have to merge this data in-app (or not at all, works either way)
  # If you have a better idea, on how to merged them, I'll all ears..
  fundsClaims: [ColonyFundsClaim] @hasMany
  """
  List of native chain token claims (e.g., Token 0x0000...0000: ETH, xDAI, etc.).
  """
  # This is not an array since only a single token type can be returned
  chainFundsClaim: ColonyChainFundsClaim
    @function(name: "fetchColonyNativeFundsClaim")
  """Type of the Colony (Regular or Metacolony)."""
  type: ColonyType @index(name: "byType", queryField: "getColonyByType")
  """
  List of token balances for each domain and each token that the Colony has.
  """
  balances: ColonyBalances @function(name: "fetchColonyBalances")
  """Metadata related to the chain of the Colony."""
  chainMetadata: ChainMetadata
  """List of extensions installed in the Colony."""
  extensions: [ColonyExtension!] @hasMany(indexName: "byColony", fields: ["id"])
  """Version of the Colony."""
  version: Int!
  """List of actions that happened within the Colony."""
  actions: [ColonyAction] @hasMany
  """Metadata of the Colony."""
  metadata: ColonyMetadata @hasOne(fields: ["id"])
}

"""
Represents metadata for a Colony.
"""
type ColonyMetadata @model {
  """Unique identifier for the Colony (contract address)."""
  id: ID!
  """Display name of the Colony."""
  displayName: String!
  """URL of the Colony's avatar image."""
  avatar: String
  """URL of the Colony's thumbnail image."""
  thumbnail: String
  """List of Colony metadata changelog entries."""
  changelog: [ColonyMetadataChangelog!]
}

"""
Represents a changelog entry for Colony metadata.
"""
type ColonyMetadataChangelog {
  """Transaction hash associated with the changelog entry."""
  transactionHash: String!
  """Display name of the Colony before the change."""
  oldDisplayName: String!
  """Display name of the Colony after the change."""
  newDisplayName: String!
  """Indicates whether the avatar has changed."""
  hasAvatarChanged: Boolean!
}

"""
Represents a User within the Colony Network.
"""
type User @model {
  """Unique identifier for the User (wallet address)."""
  id: ID! @index(name: "byAddress", queryField: "getUserByAddress")
  """(Short) name of the User."""
  name: String! @index(name: "byName", queryField: "getUserByName")
  """List of tokens the User is using."""
  tokens: [Token] @manyToMany(relationName: "UserTokens")
  """Profile ID associated with the User."""
  profileId: ID
  """Profile information of the User."""
  profile: Profile @hasOne(fields: ["profileId"])
  """List of Colonies the User is watching."""
  watchlist: [Colony] @manyToMany(relationName: "WatchedColonies")
}

"""
Represents a Domain within the Colony Network.
"""
type Domain @model {
  """
  Unique identifier for the Domain.

  This should be in the following format: `colonyAddress_nativeId`
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  # Has to be self-managed
  id: ID!
  """Colony ID associated with the Domain."""
  colonyId: ID! @index(name: "byColony")
  """Colony associated with the Domain."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  Native ID of the Domain.

  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  nativeId: Int!
  """
  Native funding pot ID of the Domain.

  The native funding pot ID is assigned to a domain from the contract on creation
  """
  nativeFundingPotId: Int!
  """
  Native skill ID of the Domain.

  The native skill ID is assigned to a domain from the contract on creation
  """
  nativeSkillId: Int!
  """Indicates whether the Domain is the root domain (ID 1)"""
  isRoot: Boolean!
  """Metadata of the Domain."""
  metadata: DomainMetadata @hasOne(fields: ["id"])
}

"""
Represents metadata for a Domain.
"""
type DomainMetadata @model {
  """
  Unique identifier for the Domain metadata.
  This field is referenced by Domain id, so has to be in the same format: colonyAddress_nativeId
  """
  id: ID!
  """Name of the Domain."""
  name: String!
  """Description of the Domain."""
  description: String!
  """Color associated with the Domain."""
  color: DomainColor!
  """List of Domain metadata changelog entries."""
  changelog: [DomainMetadataChangelog!]
}

"""
Represents a changelog entry for Domain metadata.
"""
type DomainMetadataChangelog {
  """Transaction hash associated with the changelog entry."""
  transactionHash: String!
  """Name of the Domain before the change."""
  oldName: String!
  """Name of the Domain after the change."""
  newName: String!
  """Color of the Domain before the change."""
  oldColor: DomainColor!
  """Color of the Domain after the change."""
  newColor: DomainColor!
  """Description of the Domain before the change."""
  oldDescription: String!
  """Description of the Domain after the change."""
  newDescription: String!
}

"""
Represents a Colony Funds Claim for all ERC20 tokens (except native chain tokens)
"""
type ColonyFundsClaim @model {
  """Unique identifier for the Colony Funds Claim."""
  id: ID! @index(sortKeyFields: ["createdAt"])
  """Token associated with the Colony Funds Claim."""
  token: Token! @hasOne
  """Block number when the Funds Claim was created."""
  createdAtBlock: Int!
  """Timestamp when the Funds Claim was created."""
  createdAt: AWSDateTime!
  """Amount claimed in the Colony Funds Claim."""
  amount: String!
}

"""
Represents a native Colony Chain Funds Claim

E.g., Token 0x0000...0000: ETH, xDAI, etc.
"""
type ColonyChainFundsClaim {
  """Unique identifier for the Colony Chain Funds Claim."""
  id: ID!
  """Block number when the Chain Funds Claim was created."""
  createdAtBlock: Int!
  """Timestamp when the Chain Funds Claim was created."""
  createdAt: AWSDateTime!
  """Timestamp when the Chain Funds Claim was last updated."""
  updatedAt: AWSDateTime!
  """Amount claimed in the Colony Chain Funds Claim."""
  amount: String!
}

"""
Represents a Colony balance for a specific domain and token.
"""
# This is not a @model since it will only be returned by a lambda function
# so don't need to create tables for them
# Note that we also need input types since it treats the `balances` as available
# to "write" to at creation time, even though, even if you were to write to
# you'd never actually be able to read that data since the return is overwritten
# by the lambda function
type ColonyBalance {
  """Unique identifier for the Colony Balance. ??? Is this the colony address as well? ???"""
  id: ID!
  """Balance of the specific token in the domain."""
  balance: String!
  """Domain associated with the Colony Balance."""
  domain: Domain!
  """
  Token associated with the Colony Balance.
  Note that for the chain native token, name and symbol are empty.
  """
  token: Token!
}

"""Represents a collection of Colony balances."""
type ColonyBalances {
  """List of Colony balances."""
  items: [ColonyBalance]
}

"""Input type for specifying a Domain."""
input DomainInput {
  """Unique identifier for the Domain."""
  id: ID!
}

"""Input type for specifying a Token."""
input TokenInput {
  """Unique identifier for the Token."""
  id: ID!
}

"""
Represents an event triggered by a smart contract within the Colony Network.
"""
# This will store the relevant events we care about for a particular colony
# Altough it might also hold events emmited by other clients (eg: network or token)
# but are event pertaining to a colony
# Generally you'd want to use this from a block ingenstor, after you've processed
# data from an event, also save that even for future use
type ContractEvent @model {
  """
  Unique identifier for the Contract Event, in the format chainID_transactionHash_logIndex.
  """
  id: ID!
  """Name of the event."""
  # i'm debating if this should be a enum or not, but this was you don't have to
  # update this schema every time you want to start tracking a new event
  name: String!
  """The unique signature of the event."""
  signature: String!
  """Metadata associated with the event's chain."""
  chainMetadata: ChainMetadata!
  """Optional association with a Colony."""
  colony: Colony @hasOne
  """Optional association with a Token."""
  token: Token @hasOne
  """Optional association with a Domain."""
  domain: Domain @hasOne
  """Optional association with a User."""
  user: User @hasOne
  """Address of the agent who initiated the event."""
  agent: String!
  """Address of the target contract on the receiving end of the event."""
  target: String!
  """Optional encoded arguments as a JSON string."""
  encodedArguments: String
}

"""
Represents a single extension installed on a Colony.
"""
type ColonyExtension @model {
  """Unique identifier for the ColonyExtension."""
  id: ID!
  """The identifier of the Colony that the extension belongs to (the Colony's address)"""
  colonyId: ID!
    @index(
      name: "byColony"
      sortKeyFields: ["hash"]
      queryField: "getExtensionByColonyAndHash"
    )
  """The Colony that the extension belongs to."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  The unique hash of the extension.

  The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
  """
  hash: String!
  """The address of the user who installed the extension."""
  installedBy: String!
  """The timestamp when the extension was installed."""
  installedAt: AWSTimestamp!
  """Indicates whether the extension is deprecated."""
  isDeprecated: Boolean!
  """Indicates whether the extension has been removed."""
  isDeleted: Boolean!
  """Indicates whether the extension has been initialized."""
  isInitialized: Boolean!
  """The version number of the extension."""
  version: Int!
}

"""Represents the current version of an entity in the system."""
type CurrentVersion @model {
  """Unique identifier for the CurrentVersion."""
  id: ID!
  """The key used to look up the current version."""
  key: String! @index(name: "byKey", queryField: "getCurrentVersionByKey")
  """The current version number."""
  version: Int!
}

"""Represents an action performed within a Colony."""
type ColonyAction @model {
  """Unique identifier for the ColonyAction."""
  id: ID!
  """The identifier of the Colony that the action belongs to."""
  colonyId: ID!
    @index(
      name: "byColony"
      queryField: "getActionsByColony"
      sortKeyFields: ["createdAt"]
    )
  """The Colony that the action belongs to."""
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """The type of action performed."""
  type: ColonyActionType!
  """The block number where the action was recorded."""
  blockNumber: Int!
  """The timestamp when the action was created."""
  createdAt: AWSDateTime!
  """The Ethereum address of the action initiator. Can be a user, extension or colony."""
  initiatorAddress: ID
  # Amplify will automatically populate one of the following fields with related model if there is an initiator
  """The User who initiated the action, if applicable."""
  initiatorUser: User @hasOne(fields: ["initiatorAddress"])
  """The ColonyExtension that initiated the action, if applicable."""
  initiatorExtension: ColonyExtension @hasOne(fields: ["initiatorAddress"])
  """The Colony that initiated the action, if applicable."""
  initiatorColony: Colony @hasOne(fields: ["initiatorAddress"])
  """The Ethereum address of the action recipient, if applicable."""
  recipientAddress: ID
  """The User who received the action, if applicable."""
  recipient: User @hasOne(fields: ["recipientAddress"])
  """The amount involved in the action, if applicable."""
  amount: String
  """The Ethereum address of the token involved in the action, if applicable."""
  tokenAddress: ID
  """The Token involved in the action, if applicable."""
  token: Token @hasOne(fields: ["tokenAddress"])
  """The source Domain identifier, if applicable."""
  fromDomainId: ID
  """The source Domain of the action, if applicable."""
  fromDomain: Domain @hasOne(fields: ["fromDomainId"])
  """The target Domain identifier, if applicable."""
  toDomainId: ID
  """The target Domain of the action, if applicable."""
  toDomain: Domain @hasOne(fields: ["toDomainId"])
  """ ??? Not sure what this is ???"""
  fundamentalChainId: Int
  """The resulting new Colony version, if applicable."""
  newColonyVersion: Int
}
